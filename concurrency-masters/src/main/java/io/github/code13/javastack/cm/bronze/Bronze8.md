# 并发王者课-青铜8：分工协作-从本质认知线程的状态和动作方法

## 多线程的本质是分工协作

在并发编程中，多线程的本质也是分工协作。

所谓线程的状态、方法实现不过是为了完成线程间的分工协作。

换句话说，线程的状态存在不是目的，而是实现分工协作的方式。所以理解线程状态和驱动方法，首先要理解他们为什么要存在

## 从协作认知线程的状态

线程的状态是线程在协作中的瞬时状态，共六种：

- `NEW` : 线程新建但尚未启动时所处的状态
- `RUNNABLE` : 在 Java 虚拟机中执行的线程所处状态。需要注意的是，虽然线程当前正在被执行，但可能正在等待其他线程释放资源；
- `WAITING` : 无限期等待另外一个线程来执行特定操作来解除自己的等待状态
- `TIMED_WAITING` ：限时等待另一个线程来执行或自我解除等待状态
- `BLOCKED` : 被阻塞等待其他线程释放 Monitor Lock
- `TERMINATED` : 线程执行结束

在任意特定时刻，一个线程都只能处于上述六种状态中的一种。

需要注意的是RUNNABLE这个状态，它有些特殊。确切地说，它包含READY和RUNNING两个细分状态。

对于线程各状态的表述，你可以直接阅读JDK中的 `Thread.State` 枚举，并可以通过 `Thread.getState()` 查看当前线程的瞬时状态。

## 从线程状态变迁看背后的方法驱动

线程状态的变迁需要不同的方法来实现交流

下图所展示的正是线程间的状态变迁以及相关的驱动方法:

![](https://cdn.jsdelivr.net/gh/code-13/cloudimage/images/2021/07/19/20210719093246.jpg)

### start

完成线程状态从NEW到RUNNABLE的变迁

- 创建新的线程；
- 由新的线程执行其中的run()方法。
- 需要注意的是，不可以重复调用start()方法，否则会抛出IllegalThreadStateException异常。

### wait和notify

- wait()：看到wait()时，你可以简单粗暴地认为每个对象都有一个类似于休息室的等待队列，而wait()正是把当前线程送进了等待队列并暂停继续执行；
- notify()：如果说wait()是把当前线程送进了等待队列，那么notify()则是从等待队列中取出线程。此外，和notify()具有相似功能的还有个notifyAll()。与notify()
  不同的是，notifyAll()会取出等待队列中的所有线程；

wait 和 notify 很不靠谱

wait()和notify()在执行时都必须先获得锁，这也是你在代码中看到synchronized的原因。notify()
在释放锁的时候，会从等待队列中取出线程，此时的线程必须获得锁之后才能继续运行。那么，问题来了。如果队列中有多个线程时，notify()能取出指定的线程吗？答案是不能！

### interrupt

在Thread中，我们可以通过interrupt()中断线程。 然而，如果你细心的话，还会发现Thread中除了interrupt()方法之外，竟然还有两个长相酷似的方法：interrupted()
和isInterrupted()。这就要小心了。

- interrupt()：将线程设置为中断状态；
- interrupted()：取消线程的中断状态；
- isInterrupted()：判断线程是否处于中断状态，而不会变更线程状态。

那么，当我们调用interrupt()时，所调用对象的线程会立即抛出InterruptedException异常吗？其实不然，这里容易产生误解。

interrupt()方法只是改变了线程中的中断状态而已，并不会直接抛出中断异常。中断异常的抛出必须是当前线程在执行wait()、sleep()、join()
时才会抛出。换句话说，如果当前线程正在处理其他的逻辑运算，不会被中断，直到下次运行wait()、sleep()、join()时！

### join

主线程调用join()时，会阻塞当前线程继续运行，直到目标线程中的任务执行完毕。此外，在调用join()方法时，也可以设置超时时间。

## 小结

- 多线程的本质是协作，而状态和动作方法是实现协作的方式
- 对于本文知识点的掌握，不要从静态的角度死记硬背，而是要动静结合，从动态的方法认知静态的状态。
